![alt text](https://github.com/Lainad27/SpecialSequenceCalculator/blob/main/How%20to%20compute%20a%20special%20sequence%20(ReadMe).PNG)

Written [here](http://mathb.in/51891)

Computational Remarks (regarding "prime differences.c", the best version that needs a little bit more RAM):
1. In order to factorize the numbers, I kept a bitset where bitset[n] is false iff n is prime. Also, I kept an unsigned char array (0-256) of the prime gaps. from [Wikipedia](https://en.wikipedia.org/wiki/Prime_gap), we know that the largest prime gap before 303 billion is 500, and the prime gaps are always even, so we can divide every gap by 2 and store it in the array, sufficent to our unsigned char memory limit. Suprisingly enough, because there aren't that many primes (therefore there aren't that many prime gaps), We [know](https://en.wikipedia.org/wiki/Prime-counting_function) that the gaps unsigned char array uses less memory than the bitset.
2. We could improve the memory usage on the bitset by using [wheel factorization](https://en.wikipedia.org/wiki/Wheel_factorization). That is, because each prime is uneven (except 2), instead of defining, "a bitset where bitset[n] is false iff n is prime" we could store it in such a way where it is "a bitset where bitset[n] is false iff 2·n+1 is prime". This cuts on 50% of the memory cost. We can take this further. Because each prime is in the form of 6·n+1 or 6·n-1, we can make two bitsets "bitset1[n] is false iff 6·n+1 is prime" and "bitset2[n] is false iff 6·n-1 is prime" (two bitsets). This cut off 67% of memory usage. Again, suprisingly enough, we could do this until very high precentages (despite diminishing returns) to consume as little memory as we could computationaly afford.

Sometimes I wonder if there is a data type we could define that fits the second remark just right...
